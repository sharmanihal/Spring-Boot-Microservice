Here are the remaining key topics to make your knowledge complete. ðŸ¤“

-----

## Comparison: RestClient vs. RestTemplate vs. WebClient

Understanding where `RestClient` fits is crucial. Hereâ€™s a quick comparison of the three main Spring HTTP clients.

| Feature               | `RestTemplate`                                | `WebClient`                                        | `RestClient`                                                              |
| --------------------- | --------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------------- |
| **Paradigm** | Synchronous, Blocking                         | Asynchronous, Non-blocking (Reactive)              | **Synchronous, Blocking** |
| **API Style** | Template Method Pattern (`getForObject`, etc.) | Fluent, Functional API                             | **Fluent, Functional API** |
| **Introduced** | Spring 3.0                                    | Spring 5.0                                         | **Spring 6.1** |
| **Status** | In maintenance mode (no new features)         | Actively developed                                 | **Actively developed** |
| **Primary Use Case** | Legacy synchronous applications             | High-concurrency, reactive applications            | **Modern synchronous applications** (e.g., standard Spring MVC)           |
| **Error Handling** | Throws exceptions by default                  | Handled reactively with `.onStatus()` or `.exchange()` | **Throws exceptions by default, with easy customization via `.onStatus()`** |

**Conclusion:**

  * Use **`RestClient`** for all new **synchronous** applications. It's the modern replacement for `RestTemplate`.
  * Use **`WebClient`** for **asynchronous** or **reactive** applications (e.g., using Spring WebFlux).

-----

## Advanced Configuration and Customization

You can customize the `RestClient` bean for more advanced scenarios like setting default headers, timeouts, and interceptors.

### Example: A More Advanced `RestClient` Bean

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestClient;

@Configuration
public class AdvancedRestClientConfig {

    @Bean
    public RestClient restClientWithCustomConfig() {
        // 1. Configure timeouts for the underlying HTTP client
        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
        requestFactory.setConnectTimeout(5000); // 5 seconds
        requestFactory.setReadTimeout(5000);    // 5 seconds

        return RestClient.builder()
                .baseUrl("https://api.example.com")
                .requestFactory(requestFactory) // 2. Apply the custom request factory
                .defaultHeader("API-KEY", "your-secret-api-key") // 3. Add a default header to all requests
                .requestInterceptor((request, body, execution) -> { // 4. Add a logging interceptor
                    System.out.println("Sending request to: " + request.getURI());
                    // Don't log sensitive body content in production!
                    return execution.execute(request, body);
                })
                .build();
    }
}
```

#### Breakdown:

1.  **Timeouts:** You configure timeouts on the underlying `ClientHttpRequestFactory`. This is crucial for preventing your application threads from being stuck indefinitely.
2.  **Request Factory:** You apply the configured factory to the `RestClient` builder.
3.  **Default Headers:** `.defaultHeader()` is perfect for adding authentication tokens (`Authorization`, `API-KEY`, etc.) to every request made by this `RestClient` instance.
4.  **Interceptors:** `.requestInterceptor()` is a powerful feature for cross-cutting concerns. You can intercept every request to add logging, metrics, or dynamic headers before it's executed.

-----

## Handling Complex Requests (e.g., Query Params)

While the examples above used path variables, adding query parameters is just as easy using the URI builder.

```java
// GET /posts?userId=1&_sort=title
public List<Post> getPostsByUserSortedByTitle(int userId) {
    return this.restClient.get()
        .uri(uriBuilder -> uriBuilder
            .path("/posts")
            .queryParam("userId", userId)
            .queryParam("_sort", "title")
            .build())
        .retrieve()
        .body(new ParameterizedTypeReference<List<Post>>() {}); // For handling generic types like List<>
}
```

  * `uriBuilder`: The `.uri()` method can accept a lambda that gives you a `UriBuilder` for programmatically constructing complex URIs.
  * `ParameterizedTypeReference`: When you need to deserialize a response into a generic type (like `List<Post>` or `Map<String, User>`), you must use `ParameterizedTypeReference` to preserve the generic type information.

-----

## Testing with `MockRestServiceServer` ðŸ§ª

Testing your services without making real HTTP calls is essential. Spring provides a robust mock server for this purpose.

First, add the `spring-boot-starter-test` dependency (it's usually included by default).

#### Example Test Class:

Let's test the `getPostById` method from our `MyApiService`.

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.client.RestClientTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.client.MockRestServiceServer;
import org.springframework.web.client.HttpClientErrorException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withStatus;

@RestClientTest(MyApiService.class) // Tells Spring to configure a test environment for RestClient
class MyApiServiceTest {

    @Autowired
    private MyApiService myApiService;

    @Autowired
    private MockRestServiceServer mockServer; // The mock server to define expectations on

    @Autowired
    private ObjectMapper objectMapper; // Helper for creating JSON strings

    @BeforeEach
    void setUp() {
        // It's good practice to reset the mock server before each test
        this.mockServer.reset();
    }

    @Test
    void getPostById_whenExists_returnsPost() throws Exception {
        // 1. Arrange: Prepare the mock data and response
        Post mockPost = new Post(1, 1, "Test Title", "Test Body");
        String jsonResponse = objectMapper.writeValueAsString(mockPost);

        // 2. Expect: Define the expected request and the mock response
        this.mockServer.expect(requestTo("https://api.example.com/posts/1"))
                .andRespond(withSuccess(jsonResponse, MediaType.APPLICATION_JSON));

        // 3. Act: Call the method being tested
        Post result = myApiService.getPostById(1);

        // 4. Assert: Verify the result and that the expected call was made
        this.mockServer.verify();
        assertThat(result).isNotNull();
        assertThat(result.id()).isEqualTo(1);
        assertThat(result.title()).isEqualTo("Test Title");
    }

    @Test
    void getPostById_whenNotFound_throwsException() {
        // 1. Expect: Define a 404 response for the request
        this.mockServer.expect(requestTo("https://api.example.com/posts/999"))
                .andRespond(withStatus(HttpStatus.NOT_FOUND));

        // 2. Act & Assert: Verify that the correct exception is thrown
        assertThatThrownBy(() -> myApiService.getPostById(999))
                .isInstanceOf(HttpClientErrorException.NotFound.class);

        this.mockServer.verify();
    }
}
```

#### How it works:

1.  **`@RestClientTest`**: This annotation sets up a test slice that auto-configures `MockRestServiceServer` and injects it into your test.
2.  **`mockServer.expect(...)`**: You define what request you expect to receive (e.g., a GET to `/posts/1`).
3.  **`.andRespond(...)`**: You specify what response the mock server should return when it receives that request.
4.  **Call the method**: You execute your service logic, which internally uses the `RestClient`.
5.  **`mockServer.verify()`**: This is a crucial step that fails the test if the expected request was never made.

Now you have the complete picture. With these fundamentals, advanced configurations, and testing strategies, you have everything you need to effectively use `RestClient` in your Spring Boot applications. Happy coding\! ðŸš€
