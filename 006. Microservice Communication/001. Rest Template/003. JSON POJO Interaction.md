The mapping is **not done by `RestTemplate` itself**. It delegates this task to a library, which in a standard Spring Boot setup is **Jackson**. Understanding Jackson's rules is the key.

-----

### The Core Rules of JSON-to-POJO Mapping

Hereâ€™s how Jackson maps the data by default.

#### 1\. Do variable names need to be the same?

**Yes, by default, the names must match exactly (case-sensitive).** The key in the JSON object must be identical to the field name in your POJO.

  * **JSON:** `{"id": 101, "title": "My First Post"}`
  * **Java POJO:**
    ```java
    public class Post {
        private int id;
        private String title;
        // Getters and setters...
    }
    ```
    This works perfectly. If the POJO field was named `postTitle`, it would not be mapped and would remain `null`.

-----

#### 2\. How do you handle different naming conventions (e.g., `snake_case` vs. `camelCase`)?

This is extremely common. JSON APIs often use `snake_case` (e.g., `user_id`), while Java convention is `camelCase` (e.g., `userId`). You solve this using the **`@JsonProperty` annotation**.

The `@JsonProperty("json_key_name")` annotation tells Jackson, "Whatever the name of this Java field is, it should be mapped from the JSON key specified in the annotation."

  * **JSON:** `{"user_id": 12, "post_title": "A Great Topic"}`
  * **Java POJO with `@JsonProperty`:**
    ```java
    import com.fasterxml.jackson.annotation.JsonProperty;

    public class Post {
        @JsonProperty("user_id")
        private Long userId; // Java field is camelCase

        @JsonProperty("post_title")
        private String postTitle; // Java field is camelCase
        // Getters and setters...
    }
    ```
    This is the standard and best practice for handling naming differences.

-----

#### 3\. What if the JSON response has *more* fields than the POJO?

**The extra fields are safely ignored.** This is the default behavior and makes your client robust. If the API adds new fields to its response in the future, your application won't break.

  * **JSON:** `{ "id": 101, "title": "My Post", "views": 5000, "author": "Alex" }`
  * **Java POJO:**
    ```java
    public class Post {
        private int id;
        private String title;
        // No 'views' or 'author' field here
        // Getters and setters...
    }
    ```
    Jackson will map `id` and `title` successfully and simply discard the `views` and `author` fields from the JSON. No errors will be thrown.

-----

#### 4\. What if the POJO has fields that are *not* in the JSON response?

**The field in the POJO will be initialized to its default value.**

  * For objects (like `String`, `Long`): `null`

  * For primitive numbers (`int`, `double`): `0` or `0.0`

  * For `boolean`: `false`

  * **JSON:** `{"id": 101, "title": "A Partial Response"}`

  * **Java POJO:**

    ```java
    public class Post {
        private int id;         // Will be mapped to 101
        private String title;   // Will be mapped to "A Partial Response"
        private String body;    // Not in JSON, so it will be null
        // Getters and setters...
    }
    ```

-----

### Comprehensive Example

Let's tie this all together.

Imagine you get this complex JSON response from an API:

```json
{
  "post_id": 42,
  "post_title": "Understanding Jackson",
  "author_details": {
    "name": "Jane Doe",
    "member_since": "2023-01-15"
  },
  "published_status": true,
  "comment_count": 25
}
```

Now, let's create a POJO that only cares about the ID, title, and author's name.

```java
import com.fasterxml.jackson.annotation.JsonProperty;

// You can use @JsonIgnoreProperties(ignoreUnknown = true) at the class level
// to be explicit, but it's the default behavior anyway.
public class PostSummary {

    // Maps "post_id" from JSON to this field
    @JsonProperty("post_id")
    private int id;

    // Maps "post_title" from JSON to this field
    @JsonProperty("post_title")
    private String title;

    // We can even map from nested JSON objects.
    // However, this requires a bit more setup. For simplicity, let's assume a flatter structure
    // or a dedicated Author object. Let's just map the top-level fields for this example.

    // This field is NOT in the JSON, so it will be null
    private String summary;

    // The fields "author_details", "published_status", and "comment_count" from the JSON
    // are completely ignored because they don't have a corresponding field in our POJO.

    // Getters and Setters...
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    public String getSummary() { return summary; }
    public void setSummary(String summary) { this.summary = summary; }
}
```

### Nested (Comprehensive Example)

The outer Java class will have a field whose type is another class you've defined, representing the nested JSON object. Jackson handles the rest automatically.

-----

### Example: Mapping an Author Within a Post

Let's say your API returns a JSON object for a blog post, which includes a nested object for the author's details.

#### 1\. The Nested JSON Response

Notice that `author_details` is an object inside the main JSON object.

```json
{
  "post_id": 101,
  "post_title": "Mapping Nested Objects",
  "author_details": {
    "user_id": 9,
    "full_name": "Jane Doe",
    "member_since": "2023-10-26"
  }
}
```

#### 2\. Create a POJO for the Inner Object (`Author.java`)

First, create a class that exactly matches the structure and fields of the nested `author_details` object. We'll use `@JsonProperty` to handle the `snake_case` to `camelCase` naming conversion.

```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class Author {

    @JsonProperty("user_id")
    private int userId;

    @JsonProperty("full_name")
    private String fullName;

    @JsonProperty("member_since")
    private String memberSince;

    // Getters and Setters...
}
```

#### 3\. Create a POJO for the Outer Object (`Post.java`)

Now, create the main `Post` class. Inside it, declare a field of type `Author`. Use `@JsonProperty` to tell Jackson that the `author_details` key in the JSON should be mapped to our `author` field.

```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class Post {

    @JsonProperty("post_id")
    private int postId;

    @JsonProperty("post_title")
    private String postTitle;

    // This field's name 'author' matches our Author class.
    // The annotation maps it to the "author_details" JSON key.
    @JsonProperty("author_details")
    private Author author;

    // Getters and Setters...
}
```

#### 4\. Putting It All Together

When you use `RestTemplate`, you only need to specify the **outermost class** (`Post.class`). Jackson is smart enough to see the nested structure and will automatically create and populate the inner `Author` object.

```java
// In your service
String url = "https://api.example.com/posts/101";
Post myPost = restTemplate.getForObject(url, Post.class);

// Now you can access the nested data naturally
System.out.println("Post Title: " + myPost.getPostTitle());
System.out.println("Author Name: " + myPost.getAuthor().getFullName()); // Accessing the nested object
System.out.println("Author ID: " + myPost.getAuthor().getUserId());
```

That's it\! Jackson processes the JSON, sees the `author_details` object, creates a new instance of your `Author` class, fills it with the nested data, and then assigns that `Author` instance to the `author` field of your `Post` object.

When you use `restTemplate.getForObject(url, PostSummary.class)`, the resulting `PostSummary` object will look like this:

  * `id`: `42`
  * `title`: `"Understanding Jackson"`
  * `summary`: `null`
