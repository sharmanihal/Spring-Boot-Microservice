

### Advanced Usage and Customization

#### üìç Handling URL Variables (URI Templates)

Hardcoding values into URLs is not ideal. `RestTemplate` provides an elegant way to substitute variables into the URL, which also handles URL encoding for you.

You can pass variables as a `Map` or as `varargs`.

**Example:** Fetching a post by `id` and filtering by a query parameter `user`.
The target URL: `https://api.example.com/posts/{id}?user={userId}`

**1. Using `varargs` (variable arguments):**

```java
public Post getPostFiltered(Long id, Long userId) {
    String url = "https://api.example.com/posts/{id}?user={userId}";
    // Variables are substituted in the order they appear.
    return restTemplate.getForObject(url, Post.class, id, userId);
}
```

**2. Using a `Map`:**

```java
public Post getPostFilteredWithMap(Long id, Long userId) {
    String url = "https://api.example.com/posts/{id}?user={userId}";

    Map<String, String> urlVariables = new HashMap<>();
    urlVariables.put("id", id.toString());
    urlVariables.put("userId", userId.toString());

    return restTemplate.getForObject(url, Post.class, urlVariables);
}
```

This is much safer and cleaner than manual string concatenation.

-----

#### üì¶ Working Directly with HTTP Headers

The `exchange()` method is the best way to control headers. You wrap your request body and headers in an `HttpEntity` object.

**Example:** Sending a POST request with a custom `X-API-Key` header.

```java
public Post createPostWithApiKey(Post newPost, String apiKey) {
    String url = "https://api.example.com/posts";

    // Create headers
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    headers.set("X-API-Key", apiKey);

    // Create an HttpEntity that wraps the post object (body) and the headers
    HttpEntity<Post> requestEntity = new HttpEntity<>(newPost, headers);

    // Send it using exchange()
    ResponseEntity<Post> response = restTemplate.exchange(
            url,
            HttpMethod.POST,
            requestEntity,
            Post.class
    );

    return response.getBody();
}
```

-----

#### intercepting Requests with `ClientHttpRequestInterceptor`

Interceptors are powerful tools for applying cross-cutting concerns to every outgoing request. This is perfect for:

  * Logging all request/response details.
  * Automatically adding an authentication token (e.g., JWT Bearer token) to every request.
  * Modifying headers.

**Example:** Creating a simple logging interceptor.

**1. Implement the Interceptor:**

```java
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import java.io.IOException;

public class LoggingInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        System.out.println("Sending " + request.getMethod() + " request to " + request.getURI());

        ClientHttpResponse response = execution.execute(request, body);

        System.out.println("Received response with status code " + response.getStatusCode());
        return response;
    }
}
```

**2. Register it with your `RestTemplate` Bean:**

```java
@Configuration
public class AppConfig {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .additionalInterceptors(new LoggingInterceptor())
                .build();
    }
}
```

Now, every call made with this `RestTemplate` instance will automatically log the request and response info.

-----

#### Generic Collections (e.g., `List<Post>`)

A common challenge is deserializing a JSON array into a generic collection like `List<Post>`. If you use `restTemplate.getForObject(url, List.class)`, Java's type erasure will prevent it from knowing that the list should contain `Post` objects.

The solution is to use `ParameterizedTypeReference` with the `exchange()` method.

**Example:** Fetching all posts, which returns a JSON array.

```java
public List<Post> getAllPosts() {
    String url = "https://api.example.com/posts";

    ResponseEntity<List<Post>> response = restTemplate.exchange(
      url,
      HttpMethod.GET,
      null, // No request body or custom headers
      new ParameterizedTypeReference<List<Post>>() {} // The magic is here!
    );

    return response.getBody();
}
```

The `ParameterizedTypeReference` captures the generic type information (`List<Post>`) so Jackson (the JSON library) knows how to correctly deserialize the response.

-----

#### ‚è≥ Configuring Timeouts

By default, `RestTemplate` can wait indefinitely for a response, which is dangerous in a production system. You should always configure connection and read timeouts.

This is easily done with the `RestTemplateBuilder`.

```java
import java.time.Duration;

@Configuration
public class AppConfig {
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                // Time to wait to establish a connection
                .setConnectTimeout(Duration.ofMillis(3000))
                // Time to wait for data to be available after the connection is established
                .setReadTimeout(Duration.ofMillis(3000))
                .build();
    }
}
```
