`RestClient` is the modern, synchronous, blocking HTTP client introduced in Spring Framework 6.1 and Spring Boot 3.2. It provides a fluent, intuitive API inspired by `WebClient` but for synchronous use cases, making it the recommended replacement for the older `RestTemplate`.

-----

## Key Features of `RestClient`

  * **Fluent API:** It uses a chainable, builder-style API that is highly readable and easy to use.
  * **Synchronous & Blocking:** Designed specifically for traditional, thread-per-request scenarios where you need a simple, blocking HTTP call.
  * **Modern Foundation:** Built on top of the same non-blocking `ClientHttpRequestFactory` as `WebClient`, allowing it to benefit from modern HTTP client libraries like Netty or Jetty.
  * **Simplified Error Handling:** Offers a straightforward mechanism for handling HTTP error statuses.
  * **Easy Configuration:** Seamlessly integrates with Spring Boot's auto-configuration.

-----

## Setting Up `RestClient`

To use `RestClient`, you first need the `spring-boot-starter-web` dependency in your `pom.xml`, which is standard for most Spring web applications.

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

You create a `RestClient` instance using its builder. The best practice is to define it as a Spring Bean in a configuration class.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestClient;

@Configuration
public class AppConfig {

    @Bean
    public RestClient restClient() {
        return RestClient.builder()
                .baseUrl("https://api.example.com") // Set a base URL for all requests
                .build();
    }
}
```

You can then inject this `RestClient` bean wherever you need to make HTTP calls.

```java
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClient;

@Service
public class MyApiService {

    private final RestClient restClient;

    public MyApiService(RestClient restClient) {
        this.restClient = restClient;
    }

    // Methods to make API calls will go here
}
```

-----

## Core `RestClient` Functions

The core of `RestClient` is its chain of methods that build and execute an HTTP request. The chain typically follows this pattern:

1.  **HTTP Method:** `.get()`, `.post()`, `.put()`, `.delete()`, or `.patch()`.
2.  **URI:** `.uri()` to specify the path (appended to the base URL).
3.  **Headers/Body (Optional):** `.header()`, `.contentType()`, `.body()`.
4.  **Execution:** `.retrieve()` to execute the request.
5.  **Response Handling:** `.toEntity()` or `.body()` to extract the response.

### 1\. GET Request: Fetching Data

The **GET** method is used to retrieve data from a server. It's idempotent, meaning multiple identical requests have the same effect as one.

#### How it works:

The client sends a GET request to a specific URI. The server processes the request and sends back the requested data, typically in the response body.

#### Example:

Let's fetch a `Post` object with an ID of 1 from a placeholder API.

```java
// Assume Post.java is a simple record or POJO
// public record Post(Integer userId, Integer id, String title, String body) {}

public Post getPostById(int id) {
    return this.restClient.get()
            .uri("/posts/{id}", id) // URI template with a path variable
            .retrieve() // Execute the request
            .body(Post.class); // Deserialize the JSON response body into a Post object
}

// Usage:
// Post post = myApiService.getPostById(1);
// System.out.println(post.title());
```

  * `.uri("/posts/{id}", id)`: Sets the path. Spring automatically substitutes `{id}` with the value of the `id` variable.
  * `.retrieve()`: Sends the request and prepares to handle the response.
  * `.body(Post.class)`: Converts the response body into an instance of the `Post` class. If the response is a 4xx or 5xx error, this throws a `HttpClientErrorException` or `HttpServerErrorException`.

To get the full response including headers and status code, use `.toEntity()`.

```java
public ResponseEntity<Post> getPostEntityById(int id) {
    return this.restClient.get()
            .uri("/posts/{id}", id)
            .retrieve()
            .toEntity(Post.class); // Returns a ResponseEntity containing the body, headers, and status
}
```

-----

### 2\. POST Request: Creating Data

The **POST** method is used to send data to a server to create a new resource.

#### How it works:

The client sends a POST request with the new data (the "payload") in the request body. The server creates the resource and typically returns the newly created resource, often with a `201 Created` status code.

#### Example:

Let's create a new `Post`.

```java
public Post createPost(Post newPost) {
    return this.restClient.post()
            .uri("/posts")
            .contentType(MediaType.APPLICATION_JSON) // Set the Content-Type header
            .body(newPost) // The object to be serialized into the request body
            .retrieve()
            .body(Post.class);
}

// Usage:
// Post postToCreate = new Post(10, null, "My New Post", "This is the content.");
// Post createdPost = myApiService.createPost(postToCreate);
// System.out.println("Created Post ID: " + createdPost.id());
```

  * `.contentType(MediaType.APPLICATION_JSON)`: Informs the server that we are sending JSON data.
  * `.body(newPost)`: Serializes the `newPost` object into a JSON string and puts it in the request body.

-----

### 3\. PUT Request: Updating/Replacing Data

The **PUT** method is used to update an existing resource completely. You must send the full representation of the resource.

#### How it works:

The client sends a PUT request to a specific resource's URI, with the updated data in the request body. The server replaces the existing resource with the one provided.

#### Example:

Let's update the post with ID 1.

```java
public Post updatePost(int id, Post updatedPost) {
    return this.restClient.put()
            .uri("/posts/{id}", id)
            .contentType(MediaType.APPLICATION_JSON)
            .body(updatedPost)
            .retrieve()
            .body(Post.class);
}

// Usage:
// Post updatedData = new Post(1, 1, "An Updated Title", "Updated body content.");
// Post result = myApiService.updatePost(1, updatedData);
// System.out.println(result.title());
```

The structure is identical to the POST request, but the HTTP method (`.put()`) and the URI (targeting a specific resource) are different.

-----

### 4\. DELETE Request: Removing Data

The **DELETE** method is used to remove a specified resource.

#### How it works:

The client sends a DELETE request to the URI of the resource it wants to remove. The server deletes the resource and usually returns a `200 OK` or `204 No Content` status with an empty body.

#### Example:

Let's delete the post with ID 1.

```java
public void deletePost(int id) {
    this.restClient.delete()
            .uri("/posts/{id}", id)
            .retrieve()
            .toBodilessEntity(); // We don't expect a body, but we can check the status code
}

// Usage:
// myApiService.deletePost(1);
// System.out.println("Post 1 deleted.");
```

  * `.toBodilessEntity()`: Use this when you don't care about the response body but want to ensure the call was successful (i.e., didn't throw an exception). It returns a `ResponseEntity<Void>`.

-----

## Advanced Error Handling

By default, `.retrieve()` throws an exception for 4xx and 5xx status codes. You can customize this behavior using `.onStatus()`.

#### How it works:

`.onStatus()` accepts a predicate to match status codes and a function to handle the error. This allows you to map specific errors to custom exceptions or handle them gracefully without stopping the application.

#### Example:

Let's throw a custom `ResourceNotFoundException` for a `404 Not Found` error.

```java
// Custom exception class
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

public Post getPostWithCustomErrorHandling(int id) {
    return this.restClient.get()
            .uri("/posts/{id}", id)
            .retrieve()
            .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> {
                // Check for a specific 404 status
                if (response.getStatusCode() == HttpStatus.NOT_FOUND) {
                    throw new ResourceNotFoundException("Post with id " + id + " not found.");
                }
                // Handle other 4xx errors as default
                throw new HttpClientErrorException(response.getStatusCode());
            })
            .body(Post.class);
}
```

This gives you fine-grained control over the error handling logic, making your client more robust.
